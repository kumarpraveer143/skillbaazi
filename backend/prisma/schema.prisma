generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // or mysql
}

//////////////////////
// ENUMS
//////////////////////

enum UserRole {
  USER
  ADMIN
}

enum PostType {
  TECH
  LEARNING
  FUN
  POLL
}

enum ReactionType {
  LIKE
  USEFUL
  FUNNY
  INSIGHTFUL
}

enum FollowStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
}

enum NotificationType {
  FOLLOW_REQUEST
  FOLLOW_ACCEPTED
  POST_REACTION
  COMMENT
}

//////////////////////
// USER
//////////////////////

model User {
  id       String   @id @default(uuid())
  name     String
  email    String   @unique
  password String
  role     UserRole @default(USER)

  bio       String?
  company   String?
  skills    String[]
  isPrivate Boolean  @default(false)
  isActive  Boolean  @default(true)

  posts     Post[]
  comments  Comment[]
  reactions Reaction[]

  // Follow system
  followers Follow[] @relation("followers")
  following Follow[] @relation("following")

  sentRequests     FollowRequest[] @relation("sentRequests")
  receivedRequests FollowRequest[] @relation("receivedRequests")

  // Blocking
  blockedUsers   Block[] @relation("blockedUsers")
  blockedByUsers Block[] @relation("blockedByUsers")

  notifications Notification[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

//////////////////////
// POSTS
//////////////////////

model Post {
  id      String   @id @default(uuid())
  content String
  type    PostType

  authorId String
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)

  comments        Comment[]
  reactions       Reaction[]
  reactionSummary ReactionSummary?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([authorId, createdAt])
}

//////////////////////
// COMMENTS
//////////////////////

model Comment {
  id      String @id @default(uuid())
  content String

  postId String
  userId String

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([postId])
}

//////////////////////
// REACTIONS
//////////////////////

model Reaction {
  id   String       @id @default(uuid())
  type ReactionType

  userId String
  postId String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([userId, postId])
}

model ReactionSummary {
  postId String @id
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  likeCount       Int @default(0)
  usefulCount     Int @default(0)
  funnyCount      Int @default(0)
  insightfulCount Int @default(0)
}

//////////////////////
// FOLLOW REQUESTS
//////////////////////

model FollowRequest {
  id         String       @id @default(uuid())
  senderId   String
  receiverId String
  status     FollowStatus @default(PENDING)

  sender   User @relation("sentRequests", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User @relation("receivedRequests", fields: [receiverId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([senderId, receiverId])
  @@index([receiverId, status])
}

//////////////////////
// FOLLOW (FINAL CONNECTION)
//////////////////////

model Follow {
  id          String @id @default(uuid())
  followerId  String
  followingId String

  follower  User @relation("followers", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("following", fields: [followingId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([followerId, followingId])
  @@index([followingId])
}

//////////////////////
// BLOCK
//////////////////////

model Block {
  id        String @id @default(uuid())
  blockerId String
  blockedId String

  blocker User @relation("blockedUsers", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("blockedByUsers", fields: [blockedId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([blockerId, blockedId])
}

//////////////////////
// NOTIFICATIONS
//////////////////////

model Notification {
  id      String           @id @default(uuid())
  type    NotificationType
  message String
  isRead  Boolean          @default(false)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([userId, isRead])
}
